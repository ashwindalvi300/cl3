curl https://bootstrap.pypa.io/get-pip.py -o get-pip.py
python get-pip.py
pip --version

##################################################### Practical 1 - RPC ############################################################

############################### Server.py ##########################################
from xmlrpc.server import SimpleXMLRPCServer

def factorial(n):
    if n == 0:
        return 1
    else:
        return n * factorial(n-1)
    
server = SimpleXMLRPCServer(('localhost',8000))
server.register_function(factorial, 'calculate_factorial')
print("Server is ready to accept RPC calls....")
server.serve_forever()
##############################################################################################
python Server.py
####################################### Client.py ############################################
import xmlrpc.client

def main():
    server = xmlrpc.client.ServerProxy('http://localhost:8000')
    n = int(input("Enter the number to claculate factorial: "))
    result = server.calculate_factorial(n)
    print(f"Factorial of {n} is: {result}")

if __name__ == "__main__":
    main()
###################################################################################################################################
python Client.py
##################################################### Practical 2 - RMI ############################################################

############################### Server.py ##########################################
import Pyro4

@Pyro4.expose
class StringConcatenator:
    def concatenator(self, str1, str2):
        return str1 + str2

daemon = Pyro4.Daemon()

obj = StringConcatenator()

uri = daemon.register(obj)

print("Server URI:", uri)
daemon.requestLoop()
###################################################################################
python Server.py
############################### Client.py ##########################################
import Pyro4

uri = input("Enter the URI of the server: ")
concatenate = Pyro4.Proxy(uri)

str1 = input("Enter the first string: ")
str2 = input("Enter the second string: ")

result = concatenate.concatenator(str1, str2)  
print("Concatenated string:", result)
#########################################################################################################################################
python Client.py
############################################ Practical 3 - Character counting Hadoop #####################################################
##################### Text_File.txt #####################
Hello Hello how are you!

############################ Char_Count_Mr.py #####################################
from mrjob.job import MRJob

class MRCharCount(MRJob):
    def mapper(self, _, line):
        for char in line.strip():
            yield char, 1

    def reducer(self, char, counts):
        yield char, sum(counts)

if __name__ == '__main__':
    MRCharCount.run()
##################################################################################
python Char_Count_Mr.py Text_File.txt
pip install setuptools
############################ Word_Count_Mr.py ######################################
from mrjob.job import MRJob
import re

WORD_REGEXP = re.compile(r"[\w']+")

class MRWordCount(MRJob):

    def mapper(self, _, line):
        for word in WORD_REGEXP.findall(line):
            yield word.lower(), 1

    def reducer(self, word, counts):
        yield word, sum(counts)

if __name__ == "__main__":
    MRWordCount.run()
########################################################################################################################
python Word_Count_Mr.py Text_File.txt

##################################################### Practical - 4 Load balancing ################################################
import random

class LoadBalancer:
    def __init__(self, servers):
        self.servers = servers

    def round_robin(self):
        server_index = 0
        while True:
            yield self.servers[server_index]
            server_index = (server_index+1) % len(self.servers)

    def random_selection(self):
        while True:
            yield random.choice(self.servers)

    def least_connetion(self):
        while True:
            min_connections = min(self.servers, key = lambda x : x.connections)
            min_connections.connections += 1
            yield min_connections

class Server:
    def __init__(self, name):
        self.name = name
        self.connections = 0

def simulate_requests(load_balancer, num_requests):
    print("Simulating {} requests...\n".format(num_requests))
    for i in range(num_requests):
        server = next(load_balancer)
        print("Request {} handled by Server {}".format(i+1, server.name))

if __name__ == '__main__':
    server1 = Server("Server1")
    server2 = Server("Server2")
    server3 = Server("Server3")

    servers = [server1, server2, server3]

    lb = LoadBalancer(servers)

    load_balancer = lb.round_robin()
   # load_balancer = lb.random_selection()
    #load_balancer = lb.least_connetion()

    simulate_requests(load_balancer, 10)

###################################################################################################################################
python Load_balancing.py
##################################################### Practical - 5 Clone selection algorithm ######################################
import random
import numpy as np

def objective_function(x):
    return sum([(i ** 2) for i in x])

def generate_antibodies(num_antibodies, num_dimensions, search_space):
    antibodies = []
    for _ in range(num_antibodies):
        antibody = [random.uniform(search_space[i][0], search_space[i][1]) for i in range (num_dimensions)]
        antibodies.append(antibody)
    return antibodies

def clone(antibodies, num_clones, clone_factor):
    clones = []
    for antibody in antibodies:
        clones += [antibody] * int(num_clones * (1 / (1 + objective_function(antibody) * clone_factor)))
    return clones

def hypermutate(clones, mutation_rate, search_space):
    mutated_clones = []
    for clone in clones:
        mutated_clone = []
        for gene in range(len(clone)):
            if random.random() < mutation_rate:
                mutated_gene = clone[gene] + random.uniform(-0.5, 0.5) * (search_space[gene][1] - search_space[gene][0])
                # Clamp to search space
                mutated_gene = max(min(mutated_gene, search_space[gene][1]), search_space[gene][0])
                mutated_clone.append(mutated_gene)
            else:
                # This was missing in your code!
                mutated_clone.append(clone[gene])
        mutated_clones.append(mutated_clone)
    return mutated_clones


def select_antibodies(antibodies, clones, num_antibodies):
    combined_population = antibodies + clones
    combined_population.sort(key = lambda x : objective_function(x))
    return combined_population[:num_antibodies]

def clonal_selection_algorithm(num_antibodies, num_dimensions, search_space, num_generations, num_clones, clone_factor, mutation_rate):
    antibodies = generate_antibodies(num_antibodies, num_dimensions, search_space)

    for generation in range(num_generations):
        clones = clone(antibodies, num_clones, clone_factor)
        mutated_clones = hypermutate(clones, mutation_rate, search_space)
        antibodies = select_antibodies(antibodies, mutated_clones, num_antibodies)

        best_antibody = min(antibodies, key = lambda x : objective_function(x))
        print(f"Genration {generation + 1} : Best Antibody - {best_antibody}, Fitness - {objective_function(best_antibody)}")

    return min(antibodies, key = lambda x : objective_function(x))

if __name__ == "__main__":
    num_antibodies = 50
    num_dimensions = 3
    search_space = [(-5, 5)] * num_dimensions
    num_generations = 100
    num_clones = 10
    clone_factor = 0.1
    mutation_rate = 0.1

    best_solution = clonal_selection_algorithm(
        num_antibodies,
        num_dimensions,
        search_space,
        num_generations,
        num_clones,
        clone_factor,
        mutation_rate
    )
    print("Best Solution:", best_solution)
    print("Objective Value:", objective_function(best_solution))
########################################################################################################################################
python clone_sel_algo.py
###################################### Practical - 6 
